import os
import json
from datetime import datetime
from typing import List, Optional
from uuid import uuid4

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from starlette.middleware.cors import CORSMiddleware

app = FastAPI()

# Allow CORS for the Streamlit app
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allows all origins
    allow_credentials=True,
    allow_methods=["*"],  # Allows all methods
    allow_headers=["*"],  # Allows all headers
)

DB_FILE = "db.json"

class Note(BaseModel):
    id: Optional[str] = None
    title: str
    content: str
    updated_at: Optional[datetime] = None

def load_notes() -> List[Note]:
    if not os.path.exists(DB_FILE):
        return []
    with open(DB_FILE, "r") as f:
        notes_data = json.load(f)
    return [Note(**note) for note in notes_data]

def save_notes(notes: List[Note]):
    with open(DB_FILE, "w") as f:
        notes_data = [note.dict() for note in notes]
        json.dump(notes_data, f, indent=4, default=str)

@app.get("/notes", response_model=List[Note])
def get_notes():
    notes = load_notes()
    # Sort by updated_at descending, providing a default for None
    return sorted(notes, key=lambda x: x.updated_at if x.updated_at else datetime.min, reverse=True)

@app.post("/notes", response_model=Note, status_code=201)
def create_note(note: Note):
    notes = load_notes()
    note.id = str(uuid4())
    note.updated_at = datetime.utcnow()
    notes.append(note)
    save_notes(notes)
    return note

@app.get("/notes/{note_id}", response_model=Note)
def get_note(note_id: str):
    notes = load_notes()
    note = next((note for note in notes if note.id == note_id), None)
    if note is None:
        raise HTTPException(status_code=404, detail="Note not found")
    return note

@app.put("/notes/{note_id}", response_model=Note)
def update_note(note_id: str, updated_note: Note):
    notes = load_notes()
    note_index = next((i for i, note in enumerate(notes) if note.id == note_id), None)
    if note_index is None:
        raise HTTPException(status_code=404, detail="Note not found")
    
    note = notes[note_index]
    note.title = updated_note.title
    note.content = updated_note.content
    note.updated_at = datetime.utcnow()
    
    save_notes(notes)
    return note

@app.delete("/notes/{note_id}", status_code=204)
def delete_note(note_id: str):
    notes = load_notes()
    note_exists = any(note.id == note_id for note in notes)
    if not note_exists:
        raise HTTPException(status_code=404, detail="Note not found")

    notes_to_keep = [note for note in notes if note.id != note_id]
    save_notes(notes_to_keep)
    return

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000) 